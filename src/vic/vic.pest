WHITESPACE = _{ " " | "\t" | NEWLINE }
COMMENT = _{ !"\\" ~ "#" ~ (!NEWLINE ~ ANY)+ ~ NEWLINE? }

backup_ext = { "backup_ext" ~ "=" ~ atomic_string }
template = { "template" ~ "=" ~ atomic_string }
delimiter = { "delimiter" ~ "=" ~ atomic_string }
file = { "file" ~ "=" ~ "\"" ~ inner ~ "\"" }
files = { "files" ~ "=" ~ "[" ~ (("\"" ~ inner ~ "\"" ~ ",")* ~ ("\"" ~ inner ~ "\"")?)? ~ "]" }
pipe_in = { "pipe_in" ~ "=" ~ atomic_string }
pipe_out = { "pipe_out" ~ "=" ~ atomic_string }
write = { "write" ~ "=" ~ "\"" ~ inner ~ "\"" }
max_jobs = { "max_jobs" ~ "=" ~ "\"" ~ int ~ "\"" }
trace = { "trace" }
json = { "json" }
linewise = { "linewise" }
serial = { "serial" }
trim_fields = { "trim_fields" }
keep_mode = { "keep_mode" }
backup = { "backup" }
edit_inplace = { "edit_inplace" }
silent = { "silent" }
global_uses_line_numbers = { "global_uses_line_numbers" }

opt = {
	json |
	pipe_in |
	pipe_out |
	linewise |
	serial |
	trim_fields |
	keep_mode |
	backup_ext |
	backup |
	template |
	delimiter |
	max_jobs |
	trace |
	file |
    silent |
	global_uses_line_numbers |
	edit_inplace |
	write |
	files
}
opts_block = { "{" ~ ((opt ~ ",")* ~ opt?)? ~ "}" }
prelude = { "opts" ~ opts_block }

global = _{ "global" | "g" }
not_global = _{ "v" | "not_global" | "!global" }
move = _{ "move" | "m" }
cut = _{ "cut" | "c" }
next = { "next" | "n" }
echo = _{ "echo" }
repeat = _{ "repeat" | "r" }
return = _{ "return" | "ret" }
int = @{ ASCII_DIGIT+ }

include = { "include" ~ atomic_string }
alias = { "alias" ~ var_name ~ block }
repeat_cmd = { repeat ~ (int|var) ~ block }
global_cmd = { global ~ pattern ~ block ~ ("else" ~ block)? }
move_cmd = { move ~ vim_cmd }
echo_cmd = { echo ~ expr* }
cut_cmd = { cut ~ name_def? ~ vim_cmd }
return_cmd = { return ~ vim_cmd }
not_global_cmd = { not_global ~ pattern ~ block ~ ("else" ~ block)? }

while_block = { "while" ~ (bool_expr|bool_expr_single|var|bool) ~ block }
until_block = { "until" ~ (bool_expr|bool_expr_single|var|bool) ~ block }
if_block = { "if" ~ (bool_expr|bool_expr_single|var|bool) ~ block ~ elif_block* ~ else_block? }
elif_block = { "elif" ~ (bool_expr|bool_expr_single|var|bool) ~ block }
else_block = { "else" ~ block }

var_name = @{ (ASCII_ALPHANUMERIC | "_")+ }
var = { "$" ~ var_name }
var_declare = { "let" ~ var_name ~ "=" ~ expr }
var_add = { var_name ~ "+=" ~ (bin_expr|int|var) }
var_sub = { var_name ~ "-=" ~ (bin_expr|int|var) }
var_mult = { var_name ~ "*=" ~ (bin_expr|int|var) }
var_div = { var_name ~ "/=" ~ (bin_expr|int|var) }
var_pow = { var_name ~ "^=" ~ (bin_expr|int|var) }
var_mod = { var_name ~ "%=" ~ (bin_expr|int|var) }


bin_op = _{ add | sub | mult | div }
	add = { "+" }
	sub = { "-" }
	mult = { "*" }
	div = { "/" }
    modulo = { "%" }
    pow = { "**" }

bool_op = _{ eq | ne | lt | le | ge | gt }
	eq = { "==" }
	ne = { "!=" }
	lt = { "<" }
	le = { "<=" }
	gt = { ">" }
	ge = { ">=" }
	and = { "&&" }
	or = { "||" }
	not = { "!" }
bool_conjunction = { and | or }

unary_minus = { "-" }
bin_lit = { unary_minus? ~ int }
bool_lit = { not? ~ ("(" ~ bool_expr_single ~ ")" | value) }
bin_atom = { bin_lit | var | "(" ~ bin_expr ~ ")" }
bin_expr = { bin_atom ~ (bin_op ~ bin_atom)+ }
bool_expr_single = { (bool_lit ~ (bool_op ~ bool_lit)?) | "(" ~ bool_expr ~ ")" }
bool_expr = { bool_expr_single ~ (bool_conjunction ~ bool_expr_single)+ }
expr = { return_cmd | bin_expr | bool_expr | value }


value = { var | int | literal | bool }
bool = { true_lit | false_lit }
true_lit = { "true" }
false_lit = { "false" }

inner = ${ (("\\\\") | ("\\" ~ "\"") | (!"\"" ~ ANY))* }
atomic_string = @{ "\"" ~ inner ~ "\"" }
literal = { ("\"" ~ inner ~ "\"") }
vim_cmd = { literal | var }
pattern = { literal | var }
name_def = { "name" ~ "=" ~ "\"" ~ inner ~ "\"" }


cmd = {
  var_declare |
  var_add |
  if_block |
  while_block |
  until_block |
  var_sub |
  var_mult |
  var_div |
  var_pow |
  var_mod |
  include |
  alias |
  not_global_cmd |
  global_cmd |
  repeat_cmd |
  move_cmd |
  cut_cmd |
  echo_cmd |
  next
}

block = { "{" ~ cmd+ ~ "}" }

vic = { SOI ~ WHITESPACE* ~ prelude? ~ cmd+ ~ WHITESPACE* ~ EOI }
